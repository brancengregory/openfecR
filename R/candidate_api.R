# OpenFEC
#
# This application programming interface (API) allows you to explore the way candidates and committees fund their campaigns.    The Federal Election Commission (FEC) API is a RESTful web service supporting full-text and field-specific searches on FEC data. [Bulk downloads](https://www.fec.gov/data/advanced/?tab=bulk-data) are available on the current site. Information is tied to the underlying forms by file ID and image ID. Data is updated nightly.    There are a lot of data, and a good place to start is to use search to find interesting candidates and committees. Then, you can use their IDs to find report or line item details with the other endpoints. If you are interested in individual donors, check out contributor information in the `/schedule_a/` endpoints.    <b class=\"body\" id=\"getting_started_head\">Getting started with the openFEC API</b><br>    If you would like to use the FEC's API programmatically, you can sign up for your own API key using our form. Alternatively, you can still try out our API without an API key by using the web interface and using DEMO_KEY. Note that when you use the openFEC API you are subject to the [Terms of Service](https://github.com/fecgov/FEC/blob/master/TERMS-OF-SERVICE.md) and [Acceptable Use policy](https://github.com/fecgov/FEC/blob/master/ACCEPTABLE-USE-POLICY.md).    Signing up for an API key will enable you to place up to 1,000 calls an hour. Each call is limited to 100 results per page. You can email questions, comments or a request to get a key for 7,200 calls an hour (120 calls per minute) to <a href=\"mailto:APIinfo@fec.gov\">APIinfo@fec.gov</a>. You can also ask questions and discuss the data in a community led [group](https://groups.google.com/forum/#!forum/fec-data).    The model definitions and schema are available at [/swagger](/swagger/). This is useful for making wrappers and exploring the data.    A few restrictions limit the way you can use FEC data. For example, you can’t use contributor lists for commercial purposes or to solicit donations. [Learn more here](https://www.fec.gov/updates/sale-or-use-contributor-information/).    [Inspect our source code](https://github.com/fecgov/openFEC). We welcome issues and pull requests!    <p><br></p> <h2 class=\"title\" id=\"signup_head\">Sign up for an API key</h2> <div id=\"apidatagov_signup\">Loading signup form...</div>
#
# The version of the OpenAPI document: 1.0
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Candidate operations
#' @description openapi.Candidate
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ CandidateCandidateIdGet } \emph{  }
#'  This endpoint is useful for finding detailed information about a particular candidate. Use the &#x60;candidate_id&#x60; to find the most recent information about that candidate. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } candidate.id character
#' \item \emph{ @param } incumbent.challenge Enum < [, I, C, O] > 
#' \item \emph{ @param } has.raised.funds character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } name list( character )
#' \item \emph{ @param } sort character
#' \item \emph{ @param } state list( character )
#' \item \emph{ @param } cycle list( integer )
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } year character
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } district list( character )
#' \item \emph{ @param } candidate.status Enum < [, C, F, N, P] > 
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @param } office Enum < [, H, S, P] > 
#' \item \emph{ @param } party list( character )
#' \item \emph{ @param } page integer
#' \item \emph{ @param } election.year list( integer )
#' \item \emph{ @param } federal.funds.flag character
#' \item \emph{ @returnType } \link{CandidateDetailPage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : CandidateDetailPage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CandidateCandidateIdHistoryCycleGet } \emph{  }
#'  Find out a candidate&#39;s characteristics over time. This is particularly useful if the candidate runs for the same office in different districts or you want to know more about a candidate&#39;s previous races.  This information is organized by &#x60;candidate_id&#x60;, so it won&#39;t help you find a candidate who ran for different offices over time; candidates get a new ID for each office. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } cycle integer
#' \item \emph{ @param } candidate.id character
#' \item \emph{ @param } sort character
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } election.full character
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @returnType } \link{CandidateHistoryPage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : CandidateHistoryPage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CandidateCandidateIdHistoryGet } \emph{  }
#'  Find out a candidate&#39;s characteristics over time. This is particularly useful if the candidate runs for the same office in different districts or you want to know more about a candidate&#39;s previous races.  This information is organized by &#x60;candidate_id&#x60;, so it won&#39;t help you find a candidate who ran for different offices over time; candidates get a new ID for each office. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } candidate.id character
#' \item \emph{ @param } sort character
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } election.full character
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @returnType } \link{CandidateHistoryPage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : CandidateHistoryPage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CandidateCandidateIdTotalsGet } \emph{  }
#'  This endpoint provides information about a committee&#39;s Form 3, Form 3X, or Form 3P financial reports, which are aggregated by two-year period. We refer to two-year periods as a &#x60;cycle&#x60;.  The cycle is named after the even-numbered year and includes the year before it. To obtain totals from 2013 and 2014, you would use 2014. In odd-numbered years, the current cycle is the next year — for example, in 2015, the current cycle is 2016.  For presidential and Senate candidates, multiple two-year cycles exist between elections.  
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } candidate.id character
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } election.full character
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @param } sort character
#' \item \emph{ @param } cycle list( integer )
#' \item \emph{ @param } page integer
#' \item \emph{ @returnType } \link{CommitteeTotalsPage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : CommitteeTotalsPage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CandidatesGet } \emph{  }
#'  Fetch basic information about candidates, and use parameters to filter results to the candidates you&#39;re looking for.  Each result reflects a unique FEC candidate ID. That ID is particular to the candidate for a particular office sought. If a candidate runs for the same office multiple times, the ID stays the same. If the same person runs for another office — for example, a House candidate runs for a Senate office — that candidate will get a unique ID for each office. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } incumbent.challenge Enum < [, I, C, O] > 
#' \item \emph{ @param } has.raised.funds character
#' \item \emph{ @param } is.active.candidate character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } name list( character )
#' \item \emph{ @param } sort character
#' \item \emph{ @param } q list( character )
#' \item \emph{ @param } state list( character )
#' \item \emph{ @param } cycle list( integer )
#' \item \emph{ @param } min.first.file.date character
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } year character
#' \item \emph{ @param } max.first.file.date character
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } district list( character )
#' \item \emph{ @param } candidate.id list( character )
#' \item \emph{ @param } candidate.status Enum < [, C, F, N, P] > 
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @param } office Enum < [, H, S, P] > 
#' \item \emph{ @param } party list( character )
#' \item \emph{ @param } page integer
#' \item \emph{ @param } election.year list( integer )
#' \item \emph{ @param } federal.funds.flag character
#' \item \emph{ @returnType } \link{CandidatePage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : CandidatePage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CandidatesSearchGet } \emph{  }
#'  Fetch basic information about candidates and their principal committees.  Each result reflects a unique FEC candidate ID. That ID is assigned to the candidate for a particular office sought. If a candidate runs for the same office over time, that ID stays the same. If the same person runs for multiple offices — for example, a House candidate runs for a Senate office — that candidate will get a unique ID for each office.  The candidate endpoints primarily use data from FEC registration [Form 1](http://www.fec.gov/pdf/forms/fecfrm1.pdf) for committee information and [Form 2](http://www.fec.gov/pdf/forms/fecfrm2.pdf) for candidate information. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } incumbent.challenge Enum < [, I, C, O] > 
#' \item \emph{ @param } has.raised.funds character
#' \item \emph{ @param } is.active.candidate character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } name list( character )
#' \item \emph{ @param } sort character
#' \item \emph{ @param } q list( character )
#' \item \emph{ @param } state list( character )
#' \item \emph{ @param } cycle list( integer )
#' \item \emph{ @param } min.first.file.date character
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } year character
#' \item \emph{ @param } max.first.file.date character
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } district list( character )
#' \item \emph{ @param } candidate.id list( character )
#' \item \emph{ @param } candidate.status Enum < [, C, F, N, P] > 
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @param } office Enum < [, H, S, P] > 
#' \item \emph{ @param } party list( character )
#' \item \emph{ @param } page integer
#' \item \emph{ @param } election.year list( integer )
#' \item \emph{ @param } federal.funds.flag character
#' \item \emph{ @returnType } \link{CandidatePage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : CandidatePage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CandidatesTotalsByOfficeByPartyGet } \emph{  }
#'  Aggregated candidate receipts and disbursements grouped by office by party by cycle. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } is.active.candidate character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @param } sort character
#' \item \emph{ @param } office Enum < [, H, S, P] > 
#' \item \emph{ @param } page integer
#' \item \emph{ @param } election.year list( integer )
#' \item \emph{ @returnType } \link{TotalByOfficeByPartyPage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : TotalByOfficeByPartyPage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CandidatesTotalsByOfficeGet } \emph{  }
#'  Aggregated candidate receipts and disbursements grouped by office by cycle. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } is.active.candidate character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @param } sort character
#' \item \emph{ @param } office Enum < [, H, S, P] > 
#' \item \emph{ @param } page integer
#' \item \emph{ @param } election.year list( integer )
#' \item \emph{ @returnType } \link{TotalByOfficePage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : TotalByOfficePage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CandidatesTotalsGet } \emph{  }
#'  Aggregated candidate receipts and disbursements grouped by cycle. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } has.raised.funds character
#' \item \emph{ @param } max.receipts character
#' \item \emph{ @param } is.active.candidate character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } min.disbursements character
#' \item \emph{ @param } election.full character
#' \item \emph{ @param } min.cash.on.hand.end.period character
#' \item \emph{ @param } min.debts.owed.by.committee character
#' \item \emph{ @param } min.receipts character
#' \item \emph{ @param } sort character
#' \item \emph{ @param } q list( character )
#' \item \emph{ @param } max.disbursements character
#' \item \emph{ @param } max.cash.on.hand.end.period character
#' \item \emph{ @param } state list( character )
#' \item \emph{ @param } cycle list( integer )
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } district list( character )
#' \item \emph{ @param } candidate.id list( character )
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @param } office Enum < [, H, S, P] > 
#' \item \emph{ @param } party list( character )
#' \item \emph{ @param } max.debts.owed.by.committee character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } election.year list( integer )
#' \item \emph{ @param } federal.funds.flag character
#' \item \emph{ @returnType } \link{CandidateHistoryTotalPage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : CandidateHistoryTotalPage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CommitteeCommitteeIdCandidatesGet } \emph{  }
#'  This endpoint is useful for finding detailed information about a particular candidate. Use the &#x60;candidate_id&#x60; to find the most recent information about that candidate. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } committee.id character
#' \item \emph{ @param } incumbent.challenge Enum < [, I, C, O] > 
#' \item \emph{ @param } has.raised.funds character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } name list( character )
#' \item \emph{ @param } sort character
#' \item \emph{ @param } state list( character )
#' \item \emph{ @param } cycle list( integer )
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } year character
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } district list( character )
#' \item \emph{ @param } candidate.status Enum < [, C, F, N, P] > 
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @param } office Enum < [, H, S, P] > 
#' \item \emph{ @param } party list( character )
#' \item \emph{ @param } page integer
#' \item \emph{ @param } election.year list( integer )
#' \item \emph{ @param } federal.funds.flag character
#' \item \emph{ @returnType } \link{CandidateDetailPage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : CandidateDetailPage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CommitteeCommitteeIdCandidatesHistoryCycleGet } \emph{  }
#'  Find out a candidate&#39;s characteristics over time. This is particularly useful if the candidate runs for the same office in different districts or you want to know more about a candidate&#39;s previous races.  This information is organized by &#x60;candidate_id&#x60;, so it won&#39;t help you find a candidate who ran for different offices over time; candidates get a new ID for each office. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } cycle integer
#' \item \emph{ @param } committee.id character
#' \item \emph{ @param } sort character
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } election.full character
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @returnType } \link{CandidateHistoryPage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : CandidateHistoryPage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CommitteeCommitteeIdCandidatesHistoryGet } \emph{  }
#'  Find out a candidate&#39;s characteristics over time. This is particularly useful if the candidate runs for the same office in different districts or you want to know more about a candidate&#39;s previous races.  This information is organized by &#x60;candidate_id&#x60;, so it won&#39;t help you find a candidate who ran for different offices over time; candidates get a new ID for each office. 
#'
#' \itemize{
#' \item \emph{ @param } api.key character
#' \item \emph{ @param } committee.id character
#' \item \emph{ @param } sort character
#' \item \emph{ @param } sort.hide.null character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } election.full character
#' \item \emph{ @param } sort.nulls.last character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } sort.null.only character
#' \item \emph{ @returnType } \link{CandidateHistoryPage} \cr
#'
#'
#' \item status code : 0 | 
#'
#' \item return type : CandidateHistoryPage 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  CandidateCandidateIdGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.candidate.id <- 'candidate.id_example' # character |  A unique identifier assigned to each candidate registered with the FEC. If a person runs for several offices, that person will have separate candidate IDs for each office. 
#' var.incumbent.challenge <- ['incumbent.challenge_example'] # array[character] | One-letter code ('I', 'C', 'O') explaining if the candidate is an incumbent, a challenger, or if the seat is open.
#' var.has.raised.funds <- 'has.raised.funds_example' # character | A boolean that describes if a candidate's committee has ever received any receipts for their campaign for this particular office. (Candidates have separate candidate IDs for each office.)
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.name <- ['name_example'] # array[character] | Name (candidate or committee) to search for. Alias for 'q'.
#' var.sort <- 'name' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.state <- ['state_example'] # array[character] | US state or territory where a candidate runs for office
#' var.cycle <- [56] # array[integer] |  Two-year election cycle in which a candidate runs for office. Calculated from Form 2. The cycle begins with an odd year and is named for its ending, even year. This cycle follows the traditional house election cycle and subdivides the presidential and Senate elections into comparable two-year blocks. To retrieve data for the entire four years of a presidential term or six years of a senatorial term, you will need the `election_full` flag. 
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.year <- 'year_example' # character | Retrieve records pertaining to a particular election year. The list of election years is based on a candidate filing a statement of candidacy (F2) for that year.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.district <- ['district_example'] # array[character] | Two-digit US House distirict of the office the candidate is running for. Presidential, Senate and House at-large candidates will have District 00.
#' var.candidate.status <- ['candidate.status_example'] # array[character] | One-letter code explaining if the candidate is:         - C present candidate         - F future candidate         - N not yet a candidate         - P prior candidate 
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#' var.office <- ['office_example'] # array[character] | Federal office candidate runs for: H, S or P
#' var.party <- ['party_example'] # array[character] | Three-letter code for the party affiliated with a candidate or committee. For example, DEM for Democratic Party and REP for Republican Party.
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.election.year <- [56] # array[integer] | Year of election
#' var.federal.funds.flag <- 'federal.funds.flag_example' # character | A boolean the describes if a presidential candidate has accepted federal funds. The flag will be false for House and Senate candidates.
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CandidateCandidateIdGet(var.api.key, var.candidate.id, incumbent.challenge=var.incumbent.challenge, has.raised.funds=var.has.raised.funds, per.page=var.per.page, name=var.name, sort=var.sort, state=var.state, cycle=var.cycle, sort.hide.null=var.sort.hide.null, year=var.year, sort.nulls.last=var.sort.nulls.last, district=var.district, candidate.status=var.candidate.status, sort.null.only=var.sort.null.only, office=var.office, party=var.party, page=var.page, election.year=var.election.year, federal.funds.flag=var.federal.funds.flag)
#'
#'
#' ####################  CandidateCandidateIdHistoryCycleGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.cycle <- 56 # integer |  Two-year election cycle in which a candidate runs for office. Calculated from Form 2. The cycle begins with an odd year and is named for its ending, even year. This cycle follows the traditional house election cycle and subdivides the presidential and Senate elections into comparable two-year blocks. To retrieve data for the entire four years of a presidential term or six years of a senatorial term, you will need the `election_full` flag. 
#' var.candidate.id <- 'candidate.id_example' # character |  A unique identifier assigned to each candidate registered with the FEC. If a person runs for several offices, that person will have separate candidate IDs for each office. 
#' var.sort <- '-two_year_period' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.election.full <- TRUE # character | `True` indicates that full election period of a candidate. `False` indicates that two year election cycle.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CandidateCandidateIdHistoryCycleGet(var.api.key, var.cycle, var.candidate.id, sort=var.sort, sort.hide.null=var.sort.hide.null, per.page=var.per.page, election.full=var.election.full, sort.nulls.last=var.sort.nulls.last, page=var.page, sort.null.only=var.sort.null.only)
#'
#'
#' ####################  CandidateCandidateIdHistoryGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.candidate.id <- 'candidate.id_example' # character |  A unique identifier assigned to each candidate registered with the FEC. If a person runs for several offices, that person will have separate candidate IDs for each office. 
#' var.sort <- '-two_year_period' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.election.full <- TRUE # character | `True` indicates that full election period of a candidate. `False` indicates that two year election cycle.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CandidateCandidateIdHistoryGet(var.api.key, var.candidate.id, sort=var.sort, sort.hide.null=var.sort.hide.null, per.page=var.per.page, election.full=var.election.full, sort.nulls.last=var.sort.nulls.last, page=var.page, sort.null.only=var.sort.null.only)
#'
#'
#' ####################  CandidateCandidateIdTotalsGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.candidate.id <- 'candidate.id_example' # character |  A unique identifier assigned to each candidate registered with the FEC. If a person runs for several offices, that person will have separate candidate IDs for each office. 
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.election.full <- 'election.full_example' # character | `True` indicates that full election period of a candidate. `False` indicates that two year election cycle.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#' var.sort <- '-cycle' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.cycle <- [56] # array[integer] |  Filter records to only those that were applicable to a given two-year period.The cycle begins with an odd year and is named for its ending, even year. 
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CandidateCandidateIdTotalsGet(var.api.key, var.candidate.id, sort.hide.null=var.sort.hide.null, per.page=var.per.page, election.full=var.election.full, sort.nulls.last=var.sort.nulls.last, sort.null.only=var.sort.null.only, sort=var.sort, cycle=var.cycle, page=var.page)
#'
#'
#' ####################  CandidatesGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.incumbent.challenge <- ['incumbent.challenge_example'] # array[character] | One-letter code ('I', 'C', 'O') explaining if the candidate is an incumbent, a challenger, or if the seat is open.
#' var.has.raised.funds <- 'has.raised.funds_example' # character | A boolean that describes if a candidate's committee has ever received any receipts for their campaign for this particular office. (Candidates have separate candidate IDs for each office.)
#' var.is.active.candidate <- 'is.active.candidate_example' # character |  Candidates who are actively seeking office. If no value is specified, all candidates are returned. When True is specified, only active candidates are returned. When False is specified, only inactive candidates are returned. 
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.name <- ['name_example'] # array[character] | Name (candidate or committee) to search for. Alias for 'q'.
#' var.sort <- 'name' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.q <- ['q_example'] # array[character] | Name of candidate running for office
#' var.state <- ['state_example'] # array[character] | US state or territory where a candidate runs for office
#' var.cycle <- [56] # array[integer] |  Two-year election cycle in which a candidate runs for office. Calculated from Form 2. The cycle begins with an odd year and is named for its ending, even year. This cycle follows the traditional house election cycle and subdivides the presidential and Senate elections into comparable two-year blocks. To retrieve data for the entire four years of a presidential term or six years of a senatorial term, you will need the `election_full` flag. 
#' var.min.first.file.date <- 'min.first.file.date_example' # character | Selects all candidates whose first filing was received by the FEC after this date.
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.year <- 'year_example' # character | Retrieve records pertaining to a particular election year. The list of election years is based on a candidate filing a statement of candidacy (F2) for that year.
#' var.max.first.file.date <- 'max.first.file.date_example' # character | Selects all candidates whose first filing was received by the FEC before this date.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.district <- ['district_example'] # array[character] | Two-digit US House distirict of the office the candidate is running for. Presidential, Senate and House at-large candidates will have District 00.
#' var.candidate.id <- ['candidate.id_example'] # array[character] |  A unique identifier assigned to each candidate registered with the FEC. If a person runs for several offices, that person will have separate candidate IDs for each office. 
#' var.candidate.status <- ['candidate.status_example'] # array[character] | One-letter code explaining if the candidate is:         - C present candidate         - F future candidate         - N not yet a candidate         - P prior candidate 
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#' var.office <- ['office_example'] # array[character] | Federal office candidate runs for: H, S or P
#' var.party <- ['party_example'] # array[character] | Three-letter code for the party affiliated with a candidate or committee. For example, DEM for Democratic Party and REP for Republican Party.
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.election.year <- [56] # array[integer] | Year of election
#' var.federal.funds.flag <- 'federal.funds.flag_example' # character | A boolean the describes if a presidential candidate has accepted federal funds. The flag will be false for House and Senate candidates.
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CandidatesGet(var.api.key, incumbent.challenge=var.incumbent.challenge, has.raised.funds=var.has.raised.funds, is.active.candidate=var.is.active.candidate, per.page=var.per.page, name=var.name, sort=var.sort, q=var.q, state=var.state, cycle=var.cycle, min.first.file.date=var.min.first.file.date, sort.hide.null=var.sort.hide.null, year=var.year, max.first.file.date=var.max.first.file.date, sort.nulls.last=var.sort.nulls.last, district=var.district, candidate.id=var.candidate.id, candidate.status=var.candidate.status, sort.null.only=var.sort.null.only, office=var.office, party=var.party, page=var.page, election.year=var.election.year, federal.funds.flag=var.federal.funds.flag)
#'
#'
#' ####################  CandidatesSearchGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.incumbent.challenge <- ['incumbent.challenge_example'] # array[character] | One-letter code ('I', 'C', 'O') explaining if the candidate is an incumbent, a challenger, or if the seat is open.
#' var.has.raised.funds <- 'has.raised.funds_example' # character | A boolean that describes if a candidate's committee has ever received any receipts for their campaign for this particular office. (Candidates have separate candidate IDs for each office.)
#' var.is.active.candidate <- 'is.active.candidate_example' # character |  Candidates who are actively seeking office. If no value is specified, all candidates are returned. When True is specified, only active candidates are returned. When False is specified, only inactive candidates are returned. 
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.name <- ['name_example'] # array[character] | Name (candidate or committee) to search for. Alias for 'q'.
#' var.sort <- 'name' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.q <- ['q_example'] # array[character] | Name of candidate running for office
#' var.state <- ['state_example'] # array[character] | US state or territory where a candidate runs for office
#' var.cycle <- [56] # array[integer] |  Two-year election cycle in which a candidate runs for office. Calculated from Form 2. The cycle begins with an odd year and is named for its ending, even year. This cycle follows the traditional house election cycle and subdivides the presidential and Senate elections into comparable two-year blocks. To retrieve data for the entire four years of a presidential term or six years of a senatorial term, you will need the `election_full` flag. 
#' var.min.first.file.date <- 'min.first.file.date_example' # character | Selects all candidates whose first filing was received by the FEC after this date.
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.year <- 'year_example' # character | Retrieve records pertaining to a particular election year. The list of election years is based on a candidate filing a statement of candidacy (F2) for that year.
#' var.max.first.file.date <- 'max.first.file.date_example' # character | Selects all candidates whose first filing was received by the FEC before this date.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.district <- ['district_example'] # array[character] | Two-digit US House distirict of the office the candidate is running for. Presidential, Senate and House at-large candidates will have District 00.
#' var.candidate.id <- ['candidate.id_example'] # array[character] |  A unique identifier assigned to each candidate registered with the FEC. If a person runs for several offices, that person will have separate candidate IDs for each office. 
#' var.candidate.status <- ['candidate.status_example'] # array[character] | One-letter code explaining if the candidate is:         - C present candidate         - F future candidate         - N not yet a candidate         - P prior candidate 
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#' var.office <- ['office_example'] # array[character] | Federal office candidate runs for: H, S or P
#' var.party <- ['party_example'] # array[character] | Three-letter code for the party affiliated with a candidate or committee. For example, DEM for Democratic Party and REP for Republican Party.
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.election.year <- [56] # array[integer] | Year of election
#' var.federal.funds.flag <- 'federal.funds.flag_example' # character | A boolean the describes if a presidential candidate has accepted federal funds. The flag will be false for House and Senate candidates.
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CandidatesSearchGet(var.api.key, incumbent.challenge=var.incumbent.challenge, has.raised.funds=var.has.raised.funds, is.active.candidate=var.is.active.candidate, per.page=var.per.page, name=var.name, sort=var.sort, q=var.q, state=var.state, cycle=var.cycle, min.first.file.date=var.min.first.file.date, sort.hide.null=var.sort.hide.null, year=var.year, max.first.file.date=var.max.first.file.date, sort.nulls.last=var.sort.nulls.last, district=var.district, candidate.id=var.candidate.id, candidate.status=var.candidate.status, sort.null.only=var.sort.null.only, office=var.office, party=var.party, page=var.page, election.year=var.election.year, federal.funds.flag=var.federal.funds.flag)
#'
#'
#' ####################  CandidatesTotalsByOfficeByPartyGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.is.active.candidate <- 'is.active.candidate_example' # character |  Candidates who are actively seeking office. If no value is specified, all candidates are returned. When True is specified, only active candidates are returned. When False is specified, only inactive candidates are returned. 
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#' var.sort <- 'null' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.office <- 'office_example' # character | Federal office candidate runs for: H, S or P
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.election.year <- [56] # array[integer] |  Filter records to only those that were applicable to a given two-year period.The cycle begins with an odd year and is named for its ending, even year. 
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CandidatesTotalsByOfficeByPartyGet(var.api.key, sort.hide.null=var.sort.hide.null, is.active.candidate=var.is.active.candidate, per.page=var.per.page, sort.nulls.last=var.sort.nulls.last, sort.null.only=var.sort.null.only, sort=var.sort, office=var.office, page=var.page, election.year=var.election.year)
#'
#'
#' ####################  CandidatesTotalsByOfficeGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.is.active.candidate <- 'is.active.candidate_example' # character |  Candidates who are actively seeking office. If no value is specified, all candidates are returned. When True is specified, only active candidates are returned. When False is specified, only inactive candidates are returned. 
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#' var.sort <- 'null' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.office <- 'office_example' # character | Federal office candidate runs for: H, S or P
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.election.year <- [56] # array[integer] |  Filter records to only those that were applicable to a given two-year period.The cycle begins with an odd year and is named for its ending, even year. 
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CandidatesTotalsByOfficeGet(var.api.key, sort.hide.null=var.sort.hide.null, is.active.candidate=var.is.active.candidate, per.page=var.per.page, sort.nulls.last=var.sort.nulls.last, sort.null.only=var.sort.null.only, sort=var.sort, office=var.office, page=var.page, election.year=var.election.year)
#'
#'
#' ####################  CandidatesTotalsGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.has.raised.funds <- 'has.raised.funds_example' # character | A boolean that describes if a candidate's committee has ever received any receipts for their campaign for this particular office. (Candidates have separate candidate IDs for each office.)
#' var.max.receipts <- 'max.receipts_example' # character | Maximum aggregated receipts
#' var.is.active.candidate <- 'is.active.candidate_example' # character |  Candidates who are actively seeking office. If no value is specified, all candidates are returned. When True is specified, only active candidates are returned. When False is specified, only inactive candidates are returned. 
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.min.disbursements <- 'min.disbursements_example' # character | Minimum aggregated disbursements
#' var.election.full <- TRUE # character | `True` indicates that full election period of a candidate. `False` indicates that two year election cycle.
#' var.min.cash.on.hand.end.period <- 'min.cash.on.hand.end.period_example' # character | Minimum cash on hand
#' var.min.debts.owed.by.committee <- 'min.debts.owed.by.committee_example' # character | Minimum debt
#' var.min.receipts <- 'min.receipts_example' # character | Minimum aggregated receipts
#' var.sort <- 'null' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.q <- ['q_example'] # array[character] | Name of candidate running for office
#' var.max.disbursements <- 'max.disbursements_example' # character | Maximum aggregated disbursements
#' var.max.cash.on.hand.end.period <- 'max.cash.on.hand.end.period_example' # character | Maximum cash on hand
#' var.state <- ['state_example'] # array[character] | State of candidate
#' var.cycle <- [56] # array[integer] |  Filter records to only those that were applicable to a given two-year period.The cycle begins with an odd year and is named for its ending, even year. 
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.district <- ['district_example'] # array[character] | District of candidate
#' var.candidate.id <- ['candidate.id_example'] # array[character] |  A unique identifier assigned to each candidate registered with the FEC. If a person runs for several offices, that person will have separate candidate IDs for each office. 
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#' var.office <- ['office_example'] # array[character] | Federal office candidate runs for: H, S or P
#' var.party <- ['party_example'] # array[character] | Three-letter party code
#' var.max.debts.owed.by.committee <- 'max.debts.owed.by.committee_example' # character | Maximum debt
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.election.year <- [56] # array[integer] |  Filter records to only those that were applicable to a given two-year period.The cycle begins with an odd year and is named for its ending, even year. 
#' var.federal.funds.flag <- 'federal.funds.flag_example' # character | A boolean the describes if a presidential candidate has accepted federal funds. The flag will be false for House and Senate candidates.
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CandidatesTotalsGet(var.api.key, has.raised.funds=var.has.raised.funds, max.receipts=var.max.receipts, is.active.candidate=var.is.active.candidate, per.page=var.per.page, min.disbursements=var.min.disbursements, election.full=var.election.full, min.cash.on.hand.end.period=var.min.cash.on.hand.end.period, min.debts.owed.by.committee=var.min.debts.owed.by.committee, min.receipts=var.min.receipts, sort=var.sort, q=var.q, max.disbursements=var.max.disbursements, max.cash.on.hand.end.period=var.max.cash.on.hand.end.period, state=var.state, cycle=var.cycle, sort.hide.null=var.sort.hide.null, sort.nulls.last=var.sort.nulls.last, district=var.district, candidate.id=var.candidate.id, sort.null.only=var.sort.null.only, office=var.office, party=var.party, max.debts.owed.by.committee=var.max.debts.owed.by.committee, page=var.page, election.year=var.election.year, federal.funds.flag=var.federal.funds.flag)
#'
#'
#' ####################  CommitteeCommitteeIdCandidatesGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.committee.id <- 'committee.id_example' # character |  A unique identifier assigned to each committee or filer registered with the FEC. In general committee id's begin with the letter C which is followed by eight digits. 
#' var.incumbent.challenge <- ['incumbent.challenge_example'] # array[character] | One-letter code ('I', 'C', 'O') explaining if the candidate is an incumbent, a challenger, or if the seat is open.
#' var.has.raised.funds <- 'has.raised.funds_example' # character | A boolean that describes if a candidate's committee has ever received any receipts for their campaign for this particular office. (Candidates have separate candidate IDs for each office.)
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.name <- ['name_example'] # array[character] | Name (candidate or committee) to search for. Alias for 'q'.
#' var.sort <- 'name' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.state <- ['state_example'] # array[character] | US state or territory where a candidate runs for office
#' var.cycle <- [56] # array[integer] |  Two-year election cycle in which a candidate runs for office. Calculated from Form 2. The cycle begins with an odd year and is named for its ending, even year. This cycle follows the traditional house election cycle and subdivides the presidential and Senate elections into comparable two-year blocks. To retrieve data for the entire four years of a presidential term or six years of a senatorial term, you will need the `election_full` flag. 
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.year <- 'year_example' # character | Retrieve records pertaining to a particular election year. The list of election years is based on a candidate filing a statement of candidacy (F2) for that year.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.district <- ['district_example'] # array[character] | Two-digit US House distirict of the office the candidate is running for. Presidential, Senate and House at-large candidates will have District 00.
#' var.candidate.status <- ['candidate.status_example'] # array[character] | One-letter code explaining if the candidate is:         - C present candidate         - F future candidate         - N not yet a candidate         - P prior candidate 
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#' var.office <- ['office_example'] # array[character] | Federal office candidate runs for: H, S or P
#' var.party <- ['party_example'] # array[character] | Three-letter code for the party affiliated with a candidate or committee. For example, DEM for Democratic Party and REP for Republican Party.
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.election.year <- [56] # array[integer] | Year of election
#' var.federal.funds.flag <- 'federal.funds.flag_example' # character | A boolean the describes if a presidential candidate has accepted federal funds. The flag will be false for House and Senate candidates.
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CommitteeCommitteeIdCandidatesGet(var.api.key, var.committee.id, incumbent.challenge=var.incumbent.challenge, has.raised.funds=var.has.raised.funds, per.page=var.per.page, name=var.name, sort=var.sort, state=var.state, cycle=var.cycle, sort.hide.null=var.sort.hide.null, year=var.year, sort.nulls.last=var.sort.nulls.last, district=var.district, candidate.status=var.candidate.status, sort.null.only=var.sort.null.only, office=var.office, party=var.party, page=var.page, election.year=var.election.year, federal.funds.flag=var.federal.funds.flag)
#'
#'
#' ####################  CommitteeCommitteeIdCandidatesHistoryCycleGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.cycle <- 56 # integer |  Two-year election cycle in which a candidate runs for office. Calculated from Form 2. The cycle begins with an odd year and is named for its ending, even year. This cycle follows the traditional house election cycle and subdivides the presidential and Senate elections into comparable two-year blocks. To retrieve data for the entire four years of a presidential term or six years of a senatorial term, you will need the `election_full` flag. 
#' var.committee.id <- 'committee.id_example' # character |  A unique identifier assigned to each committee or filer registered with the FEC. In general committee id's begin with the letter C which is followed by eight digits. 
#' var.sort <- '-two_year_period' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.election.full <- TRUE # character | `True` indicates that full election period of a candidate. `False` indicates that two year election cycle.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CommitteeCommitteeIdCandidatesHistoryCycleGet(var.api.key, var.cycle, var.committee.id, sort=var.sort, sort.hide.null=var.sort.hide.null, per.page=var.per.page, election.full=var.election.full, sort.nulls.last=var.sort.nulls.last, page=var.page, sort.null.only=var.sort.null.only)
#'
#'
#' ####################  CommitteeCommitteeIdCandidatesHistoryGet  ####################
#'
#' library(openapi)
#' var.api.key <- 'DEMO_KEY' # character |  API key for https://api.data.gov. Get one at https://api.data.gov/signup. 
#' var.committee.id <- 'committee.id_example' # character |  A unique identifier assigned to each committee or filer registered with the FEC. In general committee id's begin with the letter C which is followed by eight digits. 
#' var.sort <- '-two_year_period' # character | Provide a field to sort by. Use `-` for descending order. 
#' var.sort.hide.null <- FALSE # character | Hide null values on sorted column(s).
#' var.per.page <- 20 # integer | The number of results returned per page. Defaults to 20.
#' var.election.full <- TRUE # character | `True` indicates that full election period of a candidate. `False` indicates that two year election cycle.
#' var.sort.nulls.last <- FALSE # character | Toggle that sorts null values last
#' var.page <- 1 # integer | For paginating through results, starting at page 1
#' var.sort.null.only <- FALSE # character | Toggle that filters out all rows having sort column that is non-null
#'
#' api.instance <- CandidateApi$new()
#'
#' #Configure API key authorization: ApiKeyHeaderAuth
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApiKeyQueryAuth
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: apiKey
#' api.instance$apiClient$apiKeys['api_key'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CommitteeCommitteeIdCandidatesHistoryGet(var.api.key, var.committee.id, sort=var.sort, sort.hide.null=var.sort.hide.null, per.page=var.per.page, election.full=var.election.full, sort.nulls.last=var.sort.nulls.last, page=var.page, sort.null.only=var.sort.null.only)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
CandidateApi <- R6::R6Class(
  'CandidateApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    CandidateCandidateIdGet = function(api.key, candidate.id, incumbent.challenge=NULL, has.raised.funds=NULL, per.page=20, name=NULL, sort='name', state=NULL, cycle=NULL, sort.hide.null=FALSE, year=NULL, sort.nulls.last=FALSE, district=NULL, candidate.status=NULL, sort.null.only=FALSE, office=NULL, party=NULL, page=1, election.year=NULL, federal.funds.flag=NULL, ...){
      apiResponse <- self$CandidateCandidateIdGetWithHttpInfo(api.key, candidate.id, incumbent.challenge, has.raised.funds, per.page, name, sort, state, cycle, sort.hide.null, year, sort.nulls.last, district, candidate.status, sort.null.only, office, party, page, election.year, federal.funds.flag, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CandidateCandidateIdGetWithHttpInfo = function(api.key, candidate.id, incumbent.challenge=NULL, has.raised.funds=NULL, per.page=20, name=NULL, sort='name', state=NULL, cycle=NULL, sort.hide.null=FALSE, year=NULL, sort.nulls.last=FALSE, district=NULL, candidate.status=NULL, sort.null.only=FALSE, office=NULL, party=NULL, page=1, election.year=NULL, federal.funds.flag=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      if (missing(`candidate.id`)) {
        stop("Missing required parameter `candidate.id`.")
      }

      queryParams['incumbent_challenge'] <- incumbent.challenge

      queryParams['api_key'] <- api.key

      queryParams['has_raised_funds'] <- has.raised.funds

      queryParams['per_page'] <- per.page

      queryParams['name'] <- name

      queryParams['sort'] <- sort

      queryParams['state'] <- state

      queryParams['cycle'] <- cycle

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['year'] <- year

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['district'] <- district

      queryParams['candidate_status'] <- candidate.status

      queryParams['sort_null_only'] <- sort.null.only

      queryParams['office'] <- office

      queryParams['party'] <- party

      queryParams['page'] <- page

      queryParams['election_year'] <- election.year

      queryParams['federal_funds_flag'] <- federal.funds.flag

      body <- NULL
      urlPath <- "/candidate/{candidate_id}/"
      if (!missing(`candidate.id`)) {
        urlPath <- gsub(paste0("\\{", "candidate_id", "\\}"), URLencode(as.character(`candidate.id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CandidateDetailPage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CandidateCandidateIdHistoryCycleGet = function(api.key, cycle, candidate.id, sort='-two_year_period', sort.hide.null=FALSE, per.page=20, election.full=TRUE, sort.nulls.last=FALSE, page=1, sort.null.only=FALSE, ...){
      apiResponse <- self$CandidateCandidateIdHistoryCycleGetWithHttpInfo(api.key, cycle, candidate.id, sort, sort.hide.null, per.page, election.full, sort.nulls.last, page, sort.null.only, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CandidateCandidateIdHistoryCycleGetWithHttpInfo = function(api.key, cycle, candidate.id, sort='-two_year_period', sort.hide.null=FALSE, per.page=20, election.full=TRUE, sort.nulls.last=FALSE, page=1, sort.null.only=FALSE, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      if (missing(`cycle`)) {
        stop("Missing required parameter `cycle`.")
      }

      if (missing(`candidate.id`)) {
        stop("Missing required parameter `candidate.id`.")
      }

      queryParams['sort'] <- sort

      queryParams['api_key'] <- api.key

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['per_page'] <- per.page

      queryParams['election_full'] <- election.full

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['page'] <- page

      queryParams['sort_null_only'] <- sort.null.only

      body <- NULL
      urlPath <- "/candidate/{candidate_id}/history/{cycle}/"
      if (!missing(`cycle`)) {
        urlPath <- gsub(paste0("\\{", "cycle", "\\}"), URLencode(as.character(`cycle`), reserved = TRUE), urlPath)
      }

      if (!missing(`candidate.id`)) {
        urlPath <- gsub(paste0("\\{", "candidate_id", "\\}"), URLencode(as.character(`candidate.id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CandidateHistoryPage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CandidateCandidateIdHistoryGet = function(api.key, candidate.id, sort='-two_year_period', sort.hide.null=FALSE, per.page=20, election.full=TRUE, sort.nulls.last=FALSE, page=1, sort.null.only=FALSE, ...){
      apiResponse <- self$CandidateCandidateIdHistoryGetWithHttpInfo(api.key, candidate.id, sort, sort.hide.null, per.page, election.full, sort.nulls.last, page, sort.null.only, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CandidateCandidateIdHistoryGetWithHttpInfo = function(api.key, candidate.id, sort='-two_year_period', sort.hide.null=FALSE, per.page=20, election.full=TRUE, sort.nulls.last=FALSE, page=1, sort.null.only=FALSE, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      if (missing(`candidate.id`)) {
        stop("Missing required parameter `candidate.id`.")
      }

      queryParams['sort'] <- sort

      queryParams['api_key'] <- api.key

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['per_page'] <- per.page

      queryParams['election_full'] <- election.full

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['page'] <- page

      queryParams['sort_null_only'] <- sort.null.only

      body <- NULL
      urlPath <- "/candidate/{candidate_id}/history/"
      if (!missing(`candidate.id`)) {
        urlPath <- gsub(paste0("\\{", "candidate_id", "\\}"), URLencode(as.character(`candidate.id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CandidateHistoryPage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CandidateCandidateIdTotalsGet = function(api.key, candidate.id, sort.hide.null=FALSE, per.page=20, election.full=NULL, sort.nulls.last=FALSE, sort.null.only=FALSE, sort='-cycle', cycle=NULL, page=1, ...){
      apiResponse <- self$CandidateCandidateIdTotalsGetWithHttpInfo(api.key, candidate.id, sort.hide.null, per.page, election.full, sort.nulls.last, sort.null.only, sort, cycle, page, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CandidateCandidateIdTotalsGetWithHttpInfo = function(api.key, candidate.id, sort.hide.null=FALSE, per.page=20, election.full=NULL, sort.nulls.last=FALSE, sort.null.only=FALSE, sort='-cycle', cycle=NULL, page=1, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      if (missing(`candidate.id`)) {
        stop("Missing required parameter `candidate.id`.")
      }

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['per_page'] <- per.page

      queryParams['election_full'] <- election.full

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['sort_null_only'] <- sort.null.only

      queryParams['sort'] <- sort

      queryParams['cycle'] <- cycle

      queryParams['page'] <- page

      queryParams['api_key'] <- api.key

      body <- NULL
      urlPath <- "/candidate/{candidate_id}/totals/"
      if (!missing(`candidate.id`)) {
        urlPath <- gsub(paste0("\\{", "candidate_id", "\\}"), URLencode(as.character(`candidate.id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CommitteeTotalsPage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CandidatesGet = function(api.key, incumbent.challenge=NULL, has.raised.funds=NULL, is.active.candidate=NULL, per.page=20, name=NULL, sort='name', q=NULL, state=NULL, cycle=NULL, min.first.file.date=NULL, sort.hide.null=FALSE, year=NULL, max.first.file.date=NULL, sort.nulls.last=FALSE, district=NULL, candidate.id=NULL, candidate.status=NULL, sort.null.only=FALSE, office=NULL, party=NULL, page=1, election.year=NULL, federal.funds.flag=NULL, ...){
      apiResponse <- self$CandidatesGetWithHttpInfo(api.key, incumbent.challenge, has.raised.funds, is.active.candidate, per.page, name, sort, q, state, cycle, min.first.file.date, sort.hide.null, year, max.first.file.date, sort.nulls.last, district, candidate.id, candidate.status, sort.null.only, office, party, page, election.year, federal.funds.flag, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CandidatesGetWithHttpInfo = function(api.key, incumbent.challenge=NULL, has.raised.funds=NULL, is.active.candidate=NULL, per.page=20, name=NULL, sort='name', q=NULL, state=NULL, cycle=NULL, min.first.file.date=NULL, sort.hide.null=FALSE, year=NULL, max.first.file.date=NULL, sort.nulls.last=FALSE, district=NULL, candidate.id=NULL, candidate.status=NULL, sort.null.only=FALSE, office=NULL, party=NULL, page=1, election.year=NULL, federal.funds.flag=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      queryParams['incumbent_challenge'] <- incumbent.challenge

      queryParams['api_key'] <- api.key

      queryParams['has_raised_funds'] <- has.raised.funds

      queryParams['is_active_candidate'] <- is.active.candidate

      queryParams['per_page'] <- per.page

      queryParams['name'] <- name

      queryParams['sort'] <- sort

      queryParams['q'] <- q

      queryParams['state'] <- state

      queryParams['cycle'] <- cycle

      queryParams['min_first_file_date'] <- min.first.file.date

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['year'] <- year

      queryParams['max_first_file_date'] <- max.first.file.date

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['district'] <- district

      queryParams['candidate_id'] <- candidate.id

      queryParams['candidate_status'] <- candidate.status

      queryParams['sort_null_only'] <- sort.null.only

      queryParams['office'] <- office

      queryParams['party'] <- party

      queryParams['page'] <- page

      queryParams['election_year'] <- election.year

      queryParams['federal_funds_flag'] <- federal.funds.flag

      body <- NULL
      urlPath <- "/candidates/"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CandidatePage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CandidatesSearchGet = function(api.key, incumbent.challenge=NULL, has.raised.funds=NULL, is.active.candidate=NULL, per.page=20, name=NULL, sort='name', q=NULL, state=NULL, cycle=NULL, min.first.file.date=NULL, sort.hide.null=FALSE, year=NULL, max.first.file.date=NULL, sort.nulls.last=FALSE, district=NULL, candidate.id=NULL, candidate.status=NULL, sort.null.only=FALSE, office=NULL, party=NULL, page=1, election.year=NULL, federal.funds.flag=NULL, ...){
      apiResponse <- self$CandidatesSearchGetWithHttpInfo(api.key, incumbent.challenge, has.raised.funds, is.active.candidate, per.page, name, sort, q, state, cycle, min.first.file.date, sort.hide.null, year, max.first.file.date, sort.nulls.last, district, candidate.id, candidate.status, sort.null.only, office, party, page, election.year, federal.funds.flag, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CandidatesSearchGetWithHttpInfo = function(api.key, incumbent.challenge=NULL, has.raised.funds=NULL, is.active.candidate=NULL, per.page=20, name=NULL, sort='name', q=NULL, state=NULL, cycle=NULL, min.first.file.date=NULL, sort.hide.null=FALSE, year=NULL, max.first.file.date=NULL, sort.nulls.last=FALSE, district=NULL, candidate.id=NULL, candidate.status=NULL, sort.null.only=FALSE, office=NULL, party=NULL, page=1, election.year=NULL, federal.funds.flag=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      queryParams['incumbent_challenge'] <- incumbent.challenge

      queryParams['api_key'] <- api.key

      queryParams['has_raised_funds'] <- has.raised.funds

      queryParams['is_active_candidate'] <- is.active.candidate

      queryParams['per_page'] <- per.page

      queryParams['name'] <- name

      queryParams['sort'] <- sort

      queryParams['q'] <- q

      queryParams['state'] <- state

      queryParams['cycle'] <- cycle

      queryParams['min_first_file_date'] <- min.first.file.date

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['year'] <- year

      queryParams['max_first_file_date'] <- max.first.file.date

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['district'] <- district

      queryParams['candidate_id'] <- candidate.id

      queryParams['candidate_status'] <- candidate.status

      queryParams['sort_null_only'] <- sort.null.only

      queryParams['office'] <- office

      queryParams['party'] <- party

      queryParams['page'] <- page

      queryParams['election_year'] <- election.year

      queryParams['federal_funds_flag'] <- federal.funds.flag

      body <- NULL
      urlPath <- "/candidates/search/"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CandidatePage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CandidatesTotalsByOfficeByPartyGet = function(api.key, sort.hide.null=FALSE, is.active.candidate=NULL, per.page=20, sort.nulls.last=FALSE, sort.null.only=FALSE, sort='null', office=NULL, page=1, election.year=NULL, ...){
      apiResponse <- self$CandidatesTotalsByOfficeByPartyGetWithHttpInfo(api.key, sort.hide.null, is.active.candidate, per.page, sort.nulls.last, sort.null.only, sort, office, page, election.year, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CandidatesTotalsByOfficeByPartyGetWithHttpInfo = function(api.key, sort.hide.null=FALSE, is.active.candidate=NULL, per.page=20, sort.nulls.last=FALSE, sort.null.only=FALSE, sort='null', office=NULL, page=1, election.year=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['is_active_candidate'] <- is.active.candidate

      queryParams['per_page'] <- per.page

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['sort_null_only'] <- sort.null.only

      queryParams['sort'] <- sort

      queryParams['office'] <- office

      queryParams['page'] <- page

      queryParams['election_year'] <- election.year

      queryParams['api_key'] <- api.key

      body <- NULL
      urlPath <- "/candidates/totals/by_office/by_party/"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "TotalByOfficeByPartyPage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CandidatesTotalsByOfficeGet = function(api.key, sort.hide.null=FALSE, is.active.candidate=NULL, per.page=20, sort.nulls.last=FALSE, sort.null.only=FALSE, sort='null', office=NULL, page=1, election.year=NULL, ...){
      apiResponse <- self$CandidatesTotalsByOfficeGetWithHttpInfo(api.key, sort.hide.null, is.active.candidate, per.page, sort.nulls.last, sort.null.only, sort, office, page, election.year, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CandidatesTotalsByOfficeGetWithHttpInfo = function(api.key, sort.hide.null=FALSE, is.active.candidate=NULL, per.page=20, sort.nulls.last=FALSE, sort.null.only=FALSE, sort='null', office=NULL, page=1, election.year=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['is_active_candidate'] <- is.active.candidate

      queryParams['per_page'] <- per.page

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['sort_null_only'] <- sort.null.only

      queryParams['sort'] <- sort

      queryParams['office'] <- office

      queryParams['page'] <- page

      queryParams['election_year'] <- election.year

      queryParams['api_key'] <- api.key

      body <- NULL
      urlPath <- "/candidates/totals/by_office/"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "TotalByOfficePage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CandidatesTotalsGet = function(api.key, has.raised.funds=NULL, max.receipts=NULL, is.active.candidate=NULL, per.page=20, min.disbursements=NULL, election.full=TRUE, min.cash.on.hand.end.period=NULL, min.debts.owed.by.committee=NULL, min.receipts=NULL, sort='null', q=NULL, max.disbursements=NULL, max.cash.on.hand.end.period=NULL, state=NULL, cycle=NULL, sort.hide.null=FALSE, sort.nulls.last=FALSE, district=NULL, candidate.id=NULL, sort.null.only=FALSE, office=NULL, party=NULL, max.debts.owed.by.committee=NULL, page=1, election.year=NULL, federal.funds.flag=NULL, ...){
      apiResponse <- self$CandidatesTotalsGetWithHttpInfo(api.key, has.raised.funds, max.receipts, is.active.candidate, per.page, min.disbursements, election.full, min.cash.on.hand.end.period, min.debts.owed.by.committee, min.receipts, sort, q, max.disbursements, max.cash.on.hand.end.period, state, cycle, sort.hide.null, sort.nulls.last, district, candidate.id, sort.null.only, office, party, max.debts.owed.by.committee, page, election.year, federal.funds.flag, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CandidatesTotalsGetWithHttpInfo = function(api.key, has.raised.funds=NULL, max.receipts=NULL, is.active.candidate=NULL, per.page=20, min.disbursements=NULL, election.full=TRUE, min.cash.on.hand.end.period=NULL, min.debts.owed.by.committee=NULL, min.receipts=NULL, sort='null', q=NULL, max.disbursements=NULL, max.cash.on.hand.end.period=NULL, state=NULL, cycle=NULL, sort.hide.null=FALSE, sort.nulls.last=FALSE, district=NULL, candidate.id=NULL, sort.null.only=FALSE, office=NULL, party=NULL, max.debts.owed.by.committee=NULL, page=1, election.year=NULL, federal.funds.flag=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      queryParams['api_key'] <- api.key

      queryParams['has_raised_funds'] <- has.raised.funds

      queryParams['max_receipts'] <- max.receipts

      queryParams['is_active_candidate'] <- is.active.candidate

      queryParams['per_page'] <- per.page

      queryParams['min_disbursements'] <- min.disbursements

      queryParams['election_full'] <- election.full

      queryParams['min_cash_on_hand_end_period'] <- min.cash.on.hand.end.period

      queryParams['min_debts_owed_by_committee'] <- min.debts.owed.by.committee

      queryParams['min_receipts'] <- min.receipts

      queryParams['sort'] <- sort

      queryParams['q'] <- q

      queryParams['max_disbursements'] <- max.disbursements

      queryParams['max_cash_on_hand_end_period'] <- max.cash.on.hand.end.period

      queryParams['state'] <- state

      queryParams['cycle'] <- cycle

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['district'] <- district

      queryParams['candidate_id'] <- candidate.id

      queryParams['sort_null_only'] <- sort.null.only

      queryParams['office'] <- office

      queryParams['party'] <- party

      queryParams['max_debts_owed_by_committee'] <- max.debts.owed.by.committee

      queryParams['page'] <- page

      queryParams['election_year'] <- election.year

      queryParams['federal_funds_flag'] <- federal.funds.flag

      body <- NULL
      urlPath <- "/candidates/totals/"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CandidateHistoryTotalPage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CommitteeCommitteeIdCandidatesGet = function(api.key, committee.id, incumbent.challenge=NULL, has.raised.funds=NULL, per.page=20, name=NULL, sort='name', state=NULL, cycle=NULL, sort.hide.null=FALSE, year=NULL, sort.nulls.last=FALSE, district=NULL, candidate.status=NULL, sort.null.only=FALSE, office=NULL, party=NULL, page=1, election.year=NULL, federal.funds.flag=NULL, ...){
      apiResponse <- self$CommitteeCommitteeIdCandidatesGetWithHttpInfo(api.key, committee.id, incumbent.challenge, has.raised.funds, per.page, name, sort, state, cycle, sort.hide.null, year, sort.nulls.last, district, candidate.status, sort.null.only, office, party, page, election.year, federal.funds.flag, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CommitteeCommitteeIdCandidatesGetWithHttpInfo = function(api.key, committee.id, incumbent.challenge=NULL, has.raised.funds=NULL, per.page=20, name=NULL, sort='name', state=NULL, cycle=NULL, sort.hide.null=FALSE, year=NULL, sort.nulls.last=FALSE, district=NULL, candidate.status=NULL, sort.null.only=FALSE, office=NULL, party=NULL, page=1, election.year=NULL, federal.funds.flag=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      if (missing(`committee.id`)) {
        stop("Missing required parameter `committee.id`.")
      }

      queryParams['incumbent_challenge'] <- incumbent.challenge

      queryParams['api_key'] <- api.key

      queryParams['has_raised_funds'] <- has.raised.funds

      queryParams['per_page'] <- per.page

      queryParams['name'] <- name

      queryParams['sort'] <- sort

      queryParams['state'] <- state

      queryParams['cycle'] <- cycle

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['year'] <- year

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['district'] <- district

      queryParams['candidate_status'] <- candidate.status

      queryParams['sort_null_only'] <- sort.null.only

      queryParams['office'] <- office

      queryParams['party'] <- party

      queryParams['page'] <- page

      queryParams['election_year'] <- election.year

      queryParams['federal_funds_flag'] <- federal.funds.flag

      body <- NULL
      urlPath <- "/committee/{committee_id}/candidates/"
      if (!missing(`committee.id`)) {
        urlPath <- gsub(paste0("\\{", "committee_id", "\\}"), URLencode(as.character(`committee.id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CandidateDetailPage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CommitteeCommitteeIdCandidatesHistoryCycleGet = function(api.key, cycle, committee.id, sort='-two_year_period', sort.hide.null=FALSE, per.page=20, election.full=TRUE, sort.nulls.last=FALSE, page=1, sort.null.only=FALSE, ...){
      apiResponse <- self$CommitteeCommitteeIdCandidatesHistoryCycleGetWithHttpInfo(api.key, cycle, committee.id, sort, sort.hide.null, per.page, election.full, sort.nulls.last, page, sort.null.only, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CommitteeCommitteeIdCandidatesHistoryCycleGetWithHttpInfo = function(api.key, cycle, committee.id, sort='-two_year_period', sort.hide.null=FALSE, per.page=20, election.full=TRUE, sort.nulls.last=FALSE, page=1, sort.null.only=FALSE, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      if (missing(`cycle`)) {
        stop("Missing required parameter `cycle`.")
      }

      if (missing(`committee.id`)) {
        stop("Missing required parameter `committee.id`.")
      }

      queryParams['sort'] <- sort

      queryParams['api_key'] <- api.key

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['per_page'] <- per.page

      queryParams['election_full'] <- election.full

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['page'] <- page

      queryParams['sort_null_only'] <- sort.null.only

      body <- NULL
      urlPath <- "/committee/{committee_id}/candidates/history/{cycle}/"
      if (!missing(`cycle`)) {
        urlPath <- gsub(paste0("\\{", "cycle", "\\}"), URLencode(as.character(`cycle`), reserved = TRUE), urlPath)
      }

      if (!missing(`committee.id`)) {
        urlPath <- gsub(paste0("\\{", "committee_id", "\\}"), URLencode(as.character(`committee.id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CandidateHistoryPage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CommitteeCommitteeIdCandidatesHistoryGet = function(api.key, committee.id, sort='-two_year_period', sort.hide.null=FALSE, per.page=20, election.full=TRUE, sort.nulls.last=FALSE, page=1, sort.null.only=FALSE, ...){
      apiResponse <- self$CommitteeCommitteeIdCandidatesHistoryGetWithHttpInfo(api.key, committee.id, sort, sort.hide.null, per.page, election.full, sort.nulls.last, page, sort.null.only, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CommitteeCommitteeIdCandidatesHistoryGetWithHttpInfo = function(api.key, committee.id, sort='-two_year_period', sort.hide.null=FALSE, per.page=20, election.full=TRUE, sort.nulls.last=FALSE, page=1, sort.null.only=FALSE, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`api.key`)) {
        stop("Missing required parameter `api.key`.")
      }

      if (missing(`committee.id`)) {
        stop("Missing required parameter `committee.id`.")
      }

      queryParams['sort'] <- sort

      queryParams['api_key'] <- api.key

      queryParams['sort_hide_null'] <- sort.hide.null

      queryParams['per_page'] <- per.page

      queryParams['election_full'] <- election.full

      queryParams['sort_nulls_last'] <- sort.nulls.last

      queryParams['page'] <- page

      queryParams['sort_null_only'] <- sort.null.only

      body <- NULL
      urlPath <- "/committee/{committee_id}/candidates/history/"
      if (!missing(`committee.id`)) {
        urlPath <- gsub(paste0("\\{", "committee_id", "\\}"), URLencode(as.character(`committee.id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }
      # API key authentication
      if ("api_key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["api_key"]) > 0) {
        queryParams['api_key'] <- paste(unlist(self$apiClient$apiKeys["api_key"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "CandidateHistoryPage", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
